# 설계 요약 문서

이 문서는 "간단한 포인트 적립 API 서버" 과제의 설계 결정 사항들을 요약합니다.

## 1. DB 설계 (ERD)

애플리케이션의 핵심 엔티티는 `UserEntity`와 `PointHistoryEntity`입니다.

### 1.1. `UserEntity`

사용자 정보를 저장합니다.

- `id`: 사용자 ID (Primary Key, string)
- `password`: 사용자 비밀번호 (string, 해싱되어 저장)
- `point`: 현재 포인트 잔액 (number, 기본값 0)
- `pointHistories`: `PointHistoryEntity`와의 1:N 관계 (사용자가 여러 포인트 내역을 가질 수 있음)

### 1.2. `PointHistoryEntity`

사용자의 포인트 적립 및 차감 내역을 저장합니다.

- `id`: 포인트 내역 ID (Primary Key, 자동 생성 number)
- `type`: 내역 타입 (`EARN` 또는 `SPEND` enum)
- `amount`: 포인트 변동 금액 (number)
- `createdAt`: 내역 생성 시간 (Date, 자동 생성)
- `user`: `UserEntity`와의 N:1 관계 (각 내역은 한 명의 사용자에게 속함)

## 2. 각 API별 흐름

"간단한 포인트 적립 API 서버 만들기"이지만 인증을 위해 [사용자에 대한 API도 필요하다 판단](<개선, 추가기능.md#개선>)했습니다.

그래서 아래 기능을 추가했습니다.

- 사용자 생성(회원가입)
- 로그인(세션 발급용)

구현된 각 API 엔드포인트의 요청 처리 흐름 설계는 다음과 같습니다.

### 2.1. `POST /api/user/` : 사용자 회원가입

새로운 사용자를 시스템에 등록합니다.

1. **요청:** `body`에 `id`와 `password`를 포함하여 서버로 전송합니다.
2. **처리:**
    - `password`를 암호화합니다.
    - 데이터베이스에 동일한 `id`를 가진 사용자가 이미 존재하는지 확인합니다.
        - 만약 존재한다면, `ConflictException` 에러를 던집니다.
    - 암호화된 `password`와 함께 사용자 정보를 데이터베이스에 저장합니다.
3. **응답:** 성공적으로 등록되면 `201 Created` 응답을 반환합니다.

### 2.2. `POST /api/user/login` : 사용자 로그인

사용자를 인증하고 세션 쿠키를 발급합니다.

1. **요청:** `body`에 `id`와 `password`를 포함하여 서버로 전송합니다.
2. **처리:**
    - 데이터베이스에 해당 `id`를 가진 사용자가 존재하는지 확인합니다.
        - 존재하지 않으면 `UnauthorizedException` 에러를 던집니다.
    - 데이터베이스에 저장된 암호화된 비밀번호와 요청된 `password`를 비교하여 검증합니다.
        - 비밀번호가 일치하지 않으면 `UnauthorizedException` 에러를 던집니다.
    - 현재 세션 스토어에 사용자 정보가 존재하는지 확인합니다.
        - 세션이 이미 존재하면 (예: 이미 로그인된 상태), 추가적인 처리를 할 수 있으나 현재 구현에서는 세션을 갱신합니다.
    - 새로운 세션을 생성하고 사용자 정보를 세션 스토어에 저장합니다.
3. **응답:** 로그인 성공 시 `201 Created` 응답과 함께 세션 쿠키를 사용자에게 전달합니다.

### 2.3. `POST /api/earn` : 사용자 포인트 적립

로그인한 사용자의 포인트를 적립합니다.

1. **요청:** `body`에 `amount` (적립할 포인트 금액)를 포함하여 서버로 전송합니다.
2. **인증:**
    - `UserSessionGuard`를 통해 세션 스토어에서 사용자 정보를 조회합니다.
    - 세션이 없거나 유효하지 않으면 `401 Unauthorized` 응답을 반환합니다.
3. **처리 (트랜잭션):**
    - 사용자의 `id`로 현재 포인트를 조회합니다.
        - 사용자를 찾을 수 없으면 `NotFoundException` 에러를 던집니다.
    - 데이터베이스에 저장된 현재 포인트와 요청된 `amount`를 합산하여 새로운 포인트 잔액을 계산합니다.
    - 포인트 적립 내역을 `PointHistoryEntity`로 생성하여 데이터베이스에 추가합니다.
    - 사용자 테이블의 `point` 필드를 새로운 잔액으로 업데이트합니다.
    - 이 모든 과정은 하나의 데이터베이스 트랜잭션 내에서 원자적으로 처리됩니다.
4. **응답:** 포인트 적립 성공 시 `201 Created` 응답과 함께 업데이트된 포인트 잔액을 반환합니다.

### 2.4. `GET /api/balance` : 잔액 조회

로그인한 사용자의 현재 포인트 잔액을 조회합니다.

1. **인증:**
    - `UserSessionGuard`를 통해 세션 스토어에서 사용자 정보를 조회합니다.
    - 세션이 없거나 유효하지 않으면 `401 Unauthorized` 응답을 반환합니다.
2. **처리 (트랜잭션):**
    - 사용자의 `id`로 현재 포인트를 조회합니다.
        - 사용자를 찾을 수 없으면 `NotFoundException` 에러를 던집니다.
3. **응답:** 잔액 조회 성공 시 `200 OK` 응답과 함께 현재 포인트 잔액을 반환합니다.

### 2.5. `GET /api/history?historyId=historyId` : 적립 및 차감 내역 조회

로그인한 사용자의 포인트 적립 및 차감 내역을 조회합니다.

1. **인증:**
    - `UserSessionGuard`를 통해 세션 스토어에서 사용자 정보를 조회합니다.
    - 세션이 없거나 유효하지 않으면 `401 Unauthorized` 응답을 반환합니다.
2. **요청:** 쿼리 파라미터 `historyId` (선택 사항)를 통해 페이지네이션 커서를 전달할 수 있습니다.
3. **처리 (트랜잭션):**
    - 사용자의 `id`와 `historyId` (커서)를 사용하여 데이터베이스에서 포인트 내역을 조회합니다.
        - `historyId`가 제공되면 해당 `historyId`보다 작은 ID를 가진 내역들을 최신순으로 조회합니다.
        - `historyId`가 없으면 최신 내역부터 조회합니다.
4. **응답:** 내역 조회 성공 시 `200 OK` 응답과 함께 `PointHistoryEntity` 배열을 반환합니다. 내역이 없으면 빈 배열을 반환합니다.
